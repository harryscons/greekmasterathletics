    function parseMarkByRule(markStr, eventName) {
        if (!markStr) return 0;
        let s = markStr.toString().trim().replace(/,/g, '.');

        // 1. Resolve rule (Prioritize Event Formula > Static Rules)
        const ev = events.find(e => e.name === eventName);
        let ruleHowto = 'Meters';
        let ruleText = '';

        if (ev && ev.formula && ev.formula.trim() !== '') {
            const f = ev.formula;
            ruleHowto = f.match(/HOWTO:\s*([^;]+)/)?.[1]?.trim() || 'Meters';
            ruleText = f.match(/Rule:\s*(.+)$/)?.[1]?.trim() || '';
            if (!ruleText) ruleText = f.match(/Rule:\s*([^;]+)/)?.[1]?.trim() || '';
        } else {
            const r = getEventRule(eventName);
            if (r) {
                ruleHowto = r.HOWTO || 'Meters';
                ruleText = r.Rule || (r.RULE1 || '') + (r.RULE2 || '');
            }
        }

        if (ruleHowto === 'Points' || ruleHowto === 'Meters') {
            return parseFloat(s) || 0;
        }

        if (ruleHowto === 'Time') {
            const dots = (s.match(/\./g) || []).length;
            const colons = (s.match(/:/g) || []).length;
            const totalSeparators = dots + colons;
            
            let finalFormat = ruleText; 
            
            // Handle conditional "IF IN MARK THERE ARE X DOTS"
            if (ruleText.toUpperCase().includes('IF IN MARK THERE ARE')) {
                const match = ruleText.match(/ARE\s+(\d+)\s+DOTS?\s+THE\s+FORMAT\s+IS\s+(.+?)\s+ELSE\s+(?:IT\s+)?FORMAT\s+IS\s+(.+)$/i);
                if (match) {
                    const reqSeps = parseInt(match[1]);
                    const formatIf = match[2];
                    const formatElse = match[3];
                    finalFormat = (totalSeparators === reqSeps) ? formatIf : formatElse;
                }
            } else if (ruleText.toUpperCase().includes('FORMAT IS')) {
                const match = ruleText.match(/FORMAT\s+IS\s+(.+)$/i);
                if (match) finalFormat = match[1];
            }

            const parts = s.split(/[:.]/);
            const lowerF = finalFormat.toLowerCase();
            
            if (lowerF.includes('hours')) {
                let h=0, m=0, sec=0, ms=0;
                if (parts.length >= 4) {
                    h = parseFloat(parts[0]); m = parseFloat(parts[1]); sec = parseFloat(parts[2]); ms = parseFloat(parts[3]);
                } else if (parts.length === 3) {
                    h = parseFloat(parts[0]); m = parseFloat(parts[1]); sec = parseFloat(parts[2]);
                } else if (parts.length === 2) {
                    h = parseFloat(parts[0]); m = parseFloat(parts[1]);
                } else {
                    h = parseFloat(parts[0]);
                }
                return (h * 3600) + (m * 60) + sec + (ms / 100);
            } else if (lowerF.includes('minutes')) {
                let m=0, sec=0, ms=0;
                if (parts.length >= 3) {
                    m = parseFloat(parts[0]); sec = parseFloat(parts[1]); ms = parseFloat(parts[2]);
                } else if (parts.length === 2) {
                    m = parseFloat(parts[0]); sec = parseFloat(parts[1]);
                } else {
                    m = parseFloat(parts[0]);
                }
                return (m * 60) + sec + (ms / 100);
            } else if (lowerF.includes('seconds')) {
                let sec=0, ms=0;
                if (parts.length >= 2) {
                    sec = parseFloat(parts[0]); ms = parseFloat(parts[1]);
                } else {
                    sec = parseFloat(parts[0]);
                }
                return sec + (ms / 100);
            }
            return parseFloat(s) || 0;
        }
        return parseFloat(s) || 0;
    }
